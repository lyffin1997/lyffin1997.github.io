<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>spring on 小黎的技术指北</title>
    <link>https://lyffin1997.github.io/tags/spring/</link>
    <description>Recent content in spring on 小黎的技术指北</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Tue, 12 Jul 2022 11:48:09 +0800</lastBuildDate><atom:link href="https://lyffin1997.github.io/tags/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>什么是AOP</title>
      <link>https://lyffin1997.github.io/spring/%E4%BB%80%E4%B9%88%E6%98%AFaop/</link>
      <pubDate>Tue, 12 Jul 2022 11:48:09 +0800</pubDate>
      
      <guid>https://lyffin1997.github.io/spring/%E4%BB%80%E4%B9%88%E6%98%AFaop/</guid>
      <description>定义：Aspect Oriented Programming 面向切面编程
   也叫动态代理 通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术 是一种概念，没有具体语言实现 将逻辑重复代码独立于业务代码之外 参考： https://my.oschina.net/guangshan/blog/1797461    目的：例如java中要想实现代码的重用，一般可以用继承或者组合的方式。但是当你修改最底层的方法时，其他的子类以及调用的方法都要修改，增加了代码开发量和出错率。（父子关系的纵向重用）
   由此AOP思想随之诞生（横向切面）    解释：例如这样一个需求：有三个访问类和一个数据类，三个访问类并发访问数据类，且一个类在访问数据时其他类不能访问，当前类访问结束其它类才能访问
    传统方法：
    创建一个抽象类   访问类继承该抽象类
  限制：
   java只能单继承，访问类无法再继承其他类 访问类因包含“锁”状态，只能被重用在有“锁”的场景，重用受限      AOP思想：
   访问类主要功能是访问数据，而不是锁 因此将“锁”抽取出来作为一个切面       实例：
    例如想要实现某个网址增加授权认证：</description>
    </item>
    
    <item>
      <title>Springboot扫描路径问题</title>
      <link>https://lyffin1997.github.io/spring/springboot%E6%89%AB%E6%8F%8F%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 12 Jul 2022 11:40:21 +0800</pubDate>
      
      <guid>https://lyffin1997.github.io/spring/springboot%E6%89%AB%E6%8F%8F%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <description>  默认扫描路径
   如下图所示，springboot启动时，会默认扫描启动类所在包及其子包中所有的配置类 启动类所在包及其子包：如图springbootweb路径下所有的文件（引入的jar包注解除外） 配置类：扫描@Component、@Configuration、@Controller、@Service等注解标记的所有类，并注入到容器中    ​   @SpringBootApplication注解的scanBasePackages属性
   若想扫描默认路径之外的路径可使用scanBasePackages指定路径，重新指定后原默认扫描路径不会再生效    ​   @ComponentScan注解
   如果注解只指定了一个路径并且该路径与默认启动路径相同，那么@ComponentScan注解不生效 如果指定了正确的路径，则@ComponentScan注解生效，默认路径失效    ​   优先级：@ComponentScan &amp;gt; scanBasePackages &amp;gt; 默认路径
  jar包扫描问题
   若第三方jar包在默认路径中，且jar包中的目录也是com.lyffin.springbootweb，那么jar包中的注解能被扫描到，其他目录的jar包无法被扫描，可通过scanBasePackages重新指定扫描路径 若第三方jar包不在默认路径中，则需要@ComponentScan注解或者scanBasePackages属性重新指定扫描路径    现实代码中重新指定的路径必须包含默认扫描路径，否则工程中的注解就扫描不到了
  </description>
    </item>
    
  </channel>
</rss>
